import { getBibleFileURL, USE_LOCAL_FILES, FALLBACK_URLS } from '../config/bibleConfig'

/**
 * Mapeamento entre nomes das leituras e arquivos JSON da B√≠blia
 */

export const bookMapping = {
  // Pentateuco
  'G√™nesis': 'genesis',
  '√äxodo': 'exodo', 
  'Lev√≠tico': 'levitico',
  'N√∫meros': 'numeros',
  'Deuteron√¥mio': 'deuteronomio',
  
  // Hist√≥ricos
  'Josu√©': 'josue',
  'Ju√≠zes': 'juizes',
  'Rute': 'rute',
  '1 Samuel': '1samuel',
  '2 Samuel': '2samuel',
  '1 Reis': '1reis',
  '2 Reis': '2reis',
  '1 Cr√¥nicas': '1cronicas',
  '2 Cr√¥nicas': '2cronicas',
  'Esdras': 'esdras',
  'Neemias': 'neemias',
  'Ester': 'ester',
  
  // Po√©ticos
  'J√≥': 'jo',
  'Salmos': 'salmos',
  'Prov√©rbios': 'proverbios',
  'Eclesiastes': 'eclesiastes',
  'Cantares': 'cantares',
  
  // Profetas Maiores
  'Isa√≠as': 'isaias',
  'Jeremias': 'jeremias',
  'Lamenta√ß√µes': 'lamentacoes',
  'Ezequiel': 'ezequiel',
  'Daniel': 'daniel',
  
  // Profetas Menores
  'Os√©ias': 'oseias',
  'Joel': 'joel',
  'Am√≥s': 'amos',
  'Obadias': 'obadias',
  'Jonas': 'jonas',
  'Miqu√©ias': 'miqueias',
  'Naum': 'naum',
  'Habacuque': 'habacuque',
  'Sofonias': 'sofonias',
  'Ageu': 'ageu',
  'Zacarias': 'zacarias',
  'Malaquias': 'malaquias',
  
  // Novo Testamento
  'Mateus': 'mateus',
  'Marcos': 'marcos',
  'Lucas': 'lucas',
  'Jo√£o': 'joao',
  'Atos': 'atos',
  'Romanos': 'romanos',
  '1 Cor√≠ntios': '1corintios',
  '2 Cor√≠ntios': '2corintios',
  'G√°latas': 'galatas',
  'Ef√©sios': 'efesios',
  'Filipenses': 'filipenses',
  'Colossenses': 'colossenses',
  '1 Tessalonicenses': '1tessalonicenses',
  '2 Tessalonicenses': '2tessalonicenses',
  '1 Tim√≥teo': '1timoteo',
  '2 Tim√≥teo': '2timoteo',
  'Tito': 'tito',
  'Filemom': 'filemom',
  'Hebreus': 'hebreus',
  'Tiago': 'tiago',
  '1 Pedro': '1pedro',
  '2 Pedro': '2pedro',
  '1 Jo√£o': '1joao',
  '2 Jo√£o': '2joao',
  '3 Jo√£o': '3joao',
  'Judas': 'judas',
  'Apocalipse': 'apocalipse'
}

/**
 * Fun√ß√£o para extrair livro e cap√≠tulos de uma leitura
 * Ex: "G√™nesis 1-3" ‚Üí { book: "genesis", chapters: [1, 2, 3] }
 */
export function parseReading(reading) {
  // Regex para capturar: "Livro X-Y" ou "Livro X"
  const match = reading.match(/^(.+?)\s+(\d+)(?:-(\d+))?$/)
  
  if (!match) {
    console.warn(`N√£o foi poss√≠vel parsear a leitura: ${reading}`)
    return null
  }
  
  const bookName = match[1].trim()
  const startChapter = parseInt(match[2])
  const endChapter = match[3] ? parseInt(match[3]) : startChapter
  
  const bookFile = bookMapping[bookName]
  if (!bookFile) {
    console.warn(`Livro n√£o encontrado no mapeamento: ${bookName}`)
    return null
  }
  
  // Gerar array de cap√≠tulos
  const chapters = []
  for (let i = startChapter; i <= endChapter; i++) {
    chapters.push(i)
  }
  
  return {
    bookName,
    bookFile,
    chapters,
    displayName: reading
  }
}

/**
 * Cache para evitar m√∫ltiplas requisi√ß√µes do mesmo livro
 */
const bibleCache = new Map()

/**
 * Fun√ß√£o para carregar um livro da B√≠blia com CDN
 */
export async function loadBibleBook(bookFile, version = 'ARA') {
  const cacheKey = `${version}-${bookFile}`
  
  // Verificar cache primeiro
  if (bibleCache.has(cacheKey)) {
    return bibleCache.get(cacheKey)
  }
  
  try {
    let bookData
    
    if (USE_LOCAL_FILES) {
      // Desenvolvimento: usar arquivos locais
      console.log(`üîß [DEV] Carregando local: /bible/${version}/${bookFile}.json`)
      const response = await fetch(`/bible/${version}/${bookFile}.json`)
      if (!response.ok) throw new Error(`Arquivo local n√£o encontrado: ${response.status}`)
      bookData = await response.json()
    } else {
      // Produ√ß√£o: usar CDN
      console.log(`üåê [PROD] Carregando de CDN: ${version}/${bookFile}.json`)
      bookData = await loadFromCDN(version, bookFile)
    }
    
    // Salvar no cache
    bibleCache.set(cacheKey, bookData)
    
    return bookData
  } catch (error) {
    console.error(`‚ùå Erro ao carregar livro ${bookFile}:`, error)
    throw error
  }
}

/**
 * Fun√ß√£o para carregar de CDN com fallback autom√°tico
 */
async function loadFromCDN(version, bookFile) {
  // Tentar URL principal do jsDelivr
  const primaryURL = getBibleFileURL(version, bookFile)
  
  try {
    console.log(`üöÄ Tentando CDN principal: ${primaryURL}`)
    const response = await fetch(primaryURL)
    if (response.ok) {
      console.log(`‚úÖ Carregado com sucesso do jsDelivr!`)
      return await response.json()
    }
    throw new Error(`CDN principal falhou: ${response.status}`)
  } catch (error) {
    console.warn(`‚ö†Ô∏è Falha no CDN principal:`, error.message)
  }
  
  // Tentar URLs de fallback
  for (let i = 0; i < FALLBACK_URLS.length; i++) {
    try {
      const fallbackURL = `${FALLBACK_URLS[i]}/${version}/${bookFile}.json`
      console.log(`üîÑ Tentando fallback ${i + 1}: ${fallbackURL}`)
      
      const response = await fetch(fallbackURL)
      if (response.ok) {
        console.log(`‚úÖ Carregado via fallback ${i + 1}!`)
        return await response.json()
      }
    } catch (error) {
      console.warn(`‚ùå Fallback ${i + 1} falhou:`, error.message)
    }
  }
  
  throw new Error(`üí• N√£o foi poss√≠vel carregar ${bookFile} de nenhuma fonte dispon√≠vel`)
}

/**
 * Fun√ß√£o principal para carregar texto de uma leitura
 * ESTRUTURA DO JSON: Pode ser duas estruturas diferentes:
 * ARA: [{ abbrev: 'gn', book: 'G√™nesis', chapters: [...] }]
 * NVI: [cap1, cap2, cap3, ...]  (array direto dos cap√≠tulos)
 */
export async function loadReadingText(reading, version = 'ARA') {
  const parsed = parseReading(reading)
  
  if (!parsed) {
    throw new Error(`N√£o foi poss√≠vel parsear a leitura: ${reading}`)
  }
  
  try {
    // Carregar o livro
    const bookData = await loadBibleBook(parsed.bookFile, version)
    
    console.log('üìö Estrutura do livro carregado:', bookData) // Debug
    
    let chaptersArray
    
    // Detectar estrutura: ARA vs NVI/ACF
    if (bookData.length === 1 && bookData[0].hasOwnProperty('chapters')) {
      // Estrutura ARA: metadata + chapters
      const bookInfo = bookData[0]
      chaptersArray = bookInfo.chapters
      console.log('üìñ Estrutura ARA detectada - Total de cap√≠tulos:', chaptersArray.length)
    } else {
      // Estrutura NVI/ACF: array direto de cap√≠tulos
      chaptersArray = bookData
      console.log('üìñ Estrutura NVI/ACF detectada - Total de cap√≠tulos:', chaptersArray.length)
    }
    
    if (!chaptersArray) {
      throw new Error(`Estrutura de dados inv√°lida para ${parsed.bookName}`)
    }
    
    console.log('üéØ Procurando cap√≠tulos:', parsed.chapters) // Debug
    
    // Extrair os cap√≠tulos necess√°rios
    const chaptersText = parsed.chapters.map(chapterNumber => {
      console.log(`üîç Buscando cap√≠tulo: ${chapterNumber}`) // Debug
      
      // Array √© 0-based, ent√£o cap√≠tulo 1 = √≠ndice 0
      const chapterIndex = chapterNumber - 1
      const chapterData = chaptersArray[chapterIndex]
      
      console.log(`üìÑ Cap√≠tulo ${chapterNumber} (√≠ndice ${chapterIndex}):`, chapterData ? 'ENCONTRADO' : 'N√ÉO ENCONTRADO') // Debug
      console.log(`üîç Estrutura do cap√≠tulo ${chapterNumber}:`, chapterData) // Debug extra
      
      if (!chapterData) {
        console.warn(`Cap√≠tulo ${chapterNumber} n√£o encontrado em ${parsed.bookName}`)
        return null
      }
      
      // Verificar se chapterData √© um objeto com vers√≠culos
      if (typeof chapterData !== 'object') {
        console.error(`Dados inv√°lidos para cap√≠tulo ${chapterNumber}:`, chapterData)
        return null
      }
      
      // A estrutura √©: {1: {1: "verso1", 2: "verso2", ...}}
      // Precisamos pegar os vers√≠culos de dentro da chave do cap√≠tulo
      const versesData = chapterData[chapterNumber.toString()]
      
      if (!versesData) {
        console.error(`Vers√≠culos n√£o encontrados para cap√≠tulo ${chapterNumber}`)
        return null
      }
      
      console.log(`üìù Vers√≠culos do cap ${chapterNumber}:`, versesData) // Debug
      
      // Converter objeto de vers√≠culos em array
      const verses = Object.entries(versesData).map(([verseNumber, verseText]) => ({
        number: parseInt(verseNumber),
        text: typeof verseText === 'string' ? verseText : String(verseText) // Garantir que seja string
      }))
      
      console.log(`üìù Total de vers√≠culos no cap ${chapterNumber}:`, verses.length) // Debug
      
      return {
        chapterNumber,
        verses,
        totalVerses: verses.length
      }
    }).filter(Boolean) // Remove cap√≠tulos nulos
    
    return {
      bookName: parsed.bookName,
      displayName: parsed.displayName,
      chapters: chaptersText,
      version
    }
  } catch (error) {
    console.error(`Erro ao carregar texto da leitura ${reading}:`, error)
    throw error
  }
}